---
title: "Downscaling climate variables with `climr`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{Downscaling climate variables with `climr`}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
bibliography: references.bib
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  fig.dim = c(7, 5),
  fig.align = "center"
)

if (!require(ggplot2)) {
  warning("'ggplot2' is not installed. Some visuals won't be available.")
}
```

## Introduction

`climr` is in essence similar to [ClimateNA](climatena.ca) in that it
downscales low-resolution (\~100km) global climate model anomalies to
high-resolution (1-4km) maps of climate, with further elevation
adjustment to user-specified elevation grids/points based on empirical
lapse rates (local relationship of climate to elevation) of the 1-4km
climate maps. The elevation-adjusted monthly values of basic climate
elements (temperature and precipitation) are then used to estimate
derived variables (e.g., degree-days, relative humidity) based on
published equations and parameters from [@wang2016].

See `vignette("methods_downscaling.Rmd")` for a detailed explanation of
the downscaling methodology employed in `climr`.

`climr`'s strenghts are:

1.  its ability to obtain multiple, individual runs of a (or several)
General Circulation Model(s) (GCM), as well as the ensemble
cross-run mean,

2.  cloud-based raw data access and local data caching,

3.  and direct `R` interface to downscaled climate elements and derived
variables covering western Canada and western US.

In this vignette we cover two basic `climr` workflows to obtain
historic and future climate projections of a few derived variables.

The first, less code-heavy, workflow uses `climr_downscale()` to do
much of the heavy lifting -- [Workflow with climr_downscale]. The second
workflow is a step-by-step breakdown of `climr_downscale()` using the
functions `climr_downscale()` calls internally -- [Workflow with
\*\_input functions and downscale].

## Main functions

Below is a list of the main functions used in the two workflows.

-   `climr_downscale()` takes a `data.table` of point coordinates (in
lat-long projection), obtains climate normals and historic and/or
future projections covering the extent of the points, which are then
downscaled using point elevation data and used to calculate derived
climate variables at the point locations. It outputs the downscaled
and derived variables in the form of a `data.table` or `SpatVector`
of points.

-   `normal_input()` downloads and prepares high-resolution climate
normals. Called internally by `climr_downscale()`.

-   `historic_input()` and `historic_input_ts()` download and prepare
low-resolution historic climate elements for a given historic period
or time series, respectively. Called internally by
`climr_downscale()`.

-   `gcm_input()`, `gcm_hist_input()` and `gcm_ts_input()` download and
prepare low-resolution climate element projections for a future
period, historic period or future time series, respectively. Called
internally by `climr_downscale()`.

-   `downscale()` downscales historic or future climate elements and
calculates derived climate variables. Called by
`climr_downscale()`.

## Workflow with `climr_downscale`

In this example workflow we use `climr_downscale()` to calculate mean
annual temperature (MAT), total annual precipitation (PPT) and relative
humidity (RH) for a historic and future period, using two separate runs
of a GCM and one emissions scenario.

We begin by loading our `data.table` of point locations, elevation and
IDs. Note that longitude ('lon') and latitude ('lat') must be in
lat-long projection and elevation in m. Point IDs must be unique.

Although we will add two other columns in our `data.table` ('ZONE' and
'HEZ') these are ignored by `climr_downscale`. The IDs, however, are
preserved and we use them later to join back the extra columns used for
plotting later on.

```{r}
library(climr)
library(data.table)
library(terra)

## we'll use a DEM of Northern Vancouver to draw our point locations from
dem_vancouver <- get(data("dem_vancouver")) |>
  unwrap()

point_locations <- as.data.table(dem_vancouver, cell = TRUE, xy = TRUE)
setnames(point_locations, c("id", "lon", "lat", "elev"))  ## change to climr-accepted column names

## sample a few points with elev > 0m
point_locations <- point_locations[elev > 0]
set.seed(123)
point_sample <- sample(1:nrow(point_locations), 
                       100, replace = FALSE)
point_locations <- point_locations[point_sample]

## join BEC zones and colours
data("BECz_vancouver")
BECz_vancouver <- unwrap(BECz_vancouver)

BECz_points <- extract(BECz_vancouver, point_locations[, .(lon, lat)]) |>
  as.data.table()
BECz_points <- BECz_points[, .(ZONE, HEX)]

point_locations <- cbind(point_locations, BECz_points)
```

The `list_*()` functions below provide a list of available historic and
future periods, GCMs, emissions scenarios, and derived variables (in
this case only the annual ones).

```{r}
list_historic()
```

```{r}
list_gcm_period()
```

```{r}
list_gcm()
```

```{r}
list_ssp()
```

```{r}
list_variables(set = "Annual")
```

We will chose the only available historic period (2001-2020), the
2021-2040 future period, the 'EC-Earth3' GCM and the SSP 2.45 scenario.
MAT, PPT and RH will be selected as output variables.

We pass our choices to `climr_downscale()`, choosing the "auto" normals
option (which defaults to using the highest resolution data available
for the points selected).

```{r, include = FALSE}
options("climr.cache.path" = file.path(tempdir(), "climr.cache"))
```

```{r, message = TRUE}
ds_out <- climr_downscale(
  xyz = point_locations,
  which_normal = "auto",
  historic_period = "2001_2020",
  gcm_period = "2021_2040",
  gcm_models = "EC-Earth3",
  ssp = "ssp245",
  max_run = 2,
  return_normal = TRUE, ## to return the 1961-1990 normals period
  vars = c("MAT", "PPT", "RH")
)
```

Note how data from historical periods doesn't have a GCM or SSP value
-- this is expected , as GCMs and SSPs are used to project future
climate values. Also, future projections were obtained for two runs of
EC-Earth3 ('r1i1p1f1' and 'r10i1p1f1'), plus the ensemble mean.

```{r, echo = FALSE, results = "asis"}
knitr::kable(ds_out[id == head(id, 1)], caption = "'ds_out' table - Output from `climr_downscale`. Outputs are show for one location ('id')")
```

To add back the extra columns we need only a simple left join.

```{r}
ds_out <- point_locations[, .(id, ZONE, HEX)][ds_out, on = .(id)]
```

We can now do a simple visualisation of climate variation by
biogeoclimatic zone ('ZONE'), in the normals period of 1961-1990:

```{r, out.width = "80%", fig.dim = c(8,5), eval = require(ggplot2), echo = TRUE}
plotdata <- melt(ds_out, measure.vars = c("MAT", "PPT", "RH"))
cols <- plotdata$HEX
names(cols) <- plotdata$ZONE
cols <- cols[!duplicated(cols)]

ggplot(plotdata[PERIOD == "1961_1990"], aes(x = ZONE, y = value, fill = ZONE)) +
  geom_boxplot() +
  theme_light() + 
  scale_fill_manual(values = cols) +
  facet_wrap(~ variable, scales = "free")
```

We may also want yearly climate projections. In this case, we want the
yearly values of MAT and PPT for 2001-2015 and 2021:2040, using the same
GCM, SSP and number of model runs. Notice how some of the data doesn't
need to be downloaded again, and was retrieved from cache.

The `climr_downscale()` internally rescales the projected historical
values so that they align with their observed counterpart. See
`vignette("methods_downscaling.Rmd")` for details.

<!-- missing data for years 2016-2020 -->

```{r, message = TRUE}
ds_out_ts <- climr_downscale(
  xyz = point_locations,
  which_normal = "auto",
  historic_ts = 2001:2015,      ## currently up to 2015
  gcm_hist_years = 2001:2020,   ## currently up to 2010
  gcm_ts_years = 2021:2040,     ## currently starting at 2021
  gcm_models = "EC-Earth3",
  ssp = "ssp245",
  max_run = 1,
  return_normal = TRUE, ## to return the 1961-1990 normals period
  vars = c("MAT", "PPT", "RH")
)
```

To plot the time series, we will filter the data to a single model run
(i.e. in this case discard the ensemble means) and to a single point
location. Note that we plot both the observed (`obs_hist`) and the
projected historical (`proj_hist`) climate values along with future
climate projections (`proj_fut`).

```{r, fig.cap = "Time series outputs from `climr_downscale`. Pannels show mean annual temperature (MAT), total annual precipitation (PPT) and relative humidity (RH). Line colours refer to observed historic values (grey), projected historic values (gren) and future projected values (blue) for a single location, GCM, emissions scenario and model run.", out.width = "80%", eval = require(ggplot2), fig.dim = c(7,8),echo = TRUE}

ds_out_ts[is.na(GCM), GCM := "Historic"]
ds_out_ts <- ds_out_ts[!grepl("ensemble", RUN)]
ds_out_ts <- ds_out_ts[!grepl("1961_1990", PERIOD)]

plotdata <- melt(ds_out_ts, measure.vars = c("MAT", "PPT", "RH"))
plotdata[, PERIOD := as.numeric(PERIOD)]
plotdata <- plotdata[id == head(id,1)]

## time series period groupings
plotdata[GCM == "Historic",  pgrp := "obs_hist"]
plotdata[GCM != "Historic" & PERIOD <= 2020,  pgrp := "proj_hist"]
plotdata[GCM != "Historic" & PERIOD > 2020,  pgrp := "proj_fut"]

## make groups so that missing data is not shown as a "line connection"
groups <- data.table(PERIOD = unique(plotdata$PERIOD))
groups[, idx := c(1, diff(PERIOD))]
i2 <- c(1, which(groups$idx != 1), nrow(groups) + 1)
groups[, grp := rep(1:length(diff(i2)), diff(i2))]
plotdata <- groups[, .(PERIOD, grp)][plotdata, on = "PERIOD"]
plotdata[, grp := paste(grp, variable, sep = "_")]

yrbreaks <- c(
  min(plotdata$PERIOD),
  seq(min(plotdata$PERIOD), max(plotdata$PERIOD), by = 5),
  max(plotdata$PERIOD)
) |>
  unique()

ggplot(plotdata, aes(x = PERIOD, y = value, col = pgrp, group = grp)) +
  geom_line(data = plotdata[pgrp == "obs_hist"], size = 1.1, 
            linejoin = "round", lineend = "round") +
  geom_line(data = plotdata[pgrp != "obs_hist"], size = 1.1, 
            linejoin = "round", lineend = "round") +
  scale_x_continuous(breaks = yrbreaks, labels = yrbreaks) +
  scale_color_manual(values = c("obs_hist" = "grey",
                                "proj_hist" =  "forestgreen", 
                                "proj_fut" = "navyblue"),
                     breaks = c("obs_hist", "proj_hist", "proj_fut")) +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5)) +
  labs(x = "Year", col = "") +
  facet_wrap(~ variable, scales = "free", ncol = 1, strip.position = "left", )

```

### Spatial output and plotting options

`climr_downscale` can also provide outputs in the form of a
`SpatVector` of points and plot the values of a chosen climate variable
from the list passed to `climr_downscale(..., vars)`, in this case MAT.

```{r, fig.dim = c(8, 6), out.width = "80%"}
ds_out_spatial <- climr_downscale(
  xyz = point_locations,
  which_normal = "auto",
  gcm_models = "EC-Earth3", 
  gcm_period = "2021_2040",
  ssp = "ssp245",
  max_run = 0,
  return_normal = FALSE, ## don't return the 1961-1990 normals period
  out_spatial = TRUE,
  plot = "MAT",
  vars = c("MAT", "PPT", "RH")
)
```

And of course we can now use the vector output to map all variables on
top of our DEM raster, for prettier visuals:

```{r, fig.show = 'hold', fig.dim = c(10, 5), out.width = "100%"}
vancouver <- get(data("vancouver")) |>
  unwrap()

par(mfrow = c(1,2))
plot(dem_vancouver, col = hcl.colors(50, palette = "Earth"),
     plg = list(x = "bottom", title = "Elevation"), 
     mar = c(4, 1, 1, 4))
plot(vancouver, add = TRUE, col = "black")
plot(ds_out_spatial, "MAT", col = hcl.colors(50, palette = "Reds"),
     add = TRUE, type = "continuous",
     plg = list(x = "right", title = "MAT"))

plot(dem_vancouver, col = hcl.colors(50, palette = "Earth"),
     plg = list(x = "bottom", title = "Elevation"), 
     mar = c(4, 1, 1, 4))
plot(vancouver, add = TRUE, col = "black")
plot(ds_out_spatial, "PPT", col = hcl.colors(50, palette = "Blues"),
     add = TRUE, type = "continuous",
     plg = list(x = "right", title = "PPT"))
```

```{r, include = FALSE}
par(mfrow = c(1,1))
```

## Workflow with `*_input` functions and `downscale`

Alternatively, a user may choose to run the climate data preparation
and downscaling functions separately.

We suggest doing this at least once or twice to have a full
understanding of the steps that `climr_downscale` executes internally.

Steps 1 and 2 bellow download and prepare the climate data used in the
downscaling step (Step 3).

We will use the same point locations as above.

### 1) Get climate normals - `normal_input()`

When using `normal_input()`, we establish a connection to the PostGIS
server and pass the bounding box containing the point locations of
interest.

Also, note that there is no "auto" option for to select the source of
climate normals. `list_normal` provides a list of available options.
'normal_na' corresponds to normals for North America obtained from
[ClimateNA](climatena.ca)[@wang2016]. 'normal_composite' corresponds to
a composite of British Columbia PRISM, adjusted US PRISM and DAYMET
(Alberta and Saskatchewan), and covers western Canada and western US. We
will use 'normal_composite'.

```{r}
list_normal()
```

```{r, out.width = "80%"}
dbCon <- data_connect()
the_bb <- get_bb(point_locations)

normals <- normal_input(dbCon, bbox = the_bb, 
                        normal = "normal_composite")
plot(normals[["Tmax07"]], col = hcl.colors(50, "Reds", rev = 1), 
     range = c(0, 30), main = "Max temp. July - 1961-1990 normals",
     fun = function() lines(vancouver, col = "grey"))
```

### 2) Get climate projections and/or historical observations

Data for historic and future climate projections can be obtained with
the `gcm_*()` functions. `gcm_hist_input()` is used to obtain historical
anomalies projected with a (or several) GCM, whereas `gcm_input()` and
`gcm_ts_input` are used to obtain future anomaly projections for a
period or individual years (i.e. time series).

Historical observations for a given period or for individual years can
be obtained with `historic_input` and `historic_input_ts`, respectively.

```{r, fig.show = 'hold', fig.dim = c(12, 5), out.width = "100%"}
hist_proj <- gcm_hist_input(dbCon, bbox = the_bb, 
                            gcm = "EC-Earth3",
                            years = 2001:2020,
                            max_run = 0)

fut_proj <- gcm_input(dbCon, bbox = the_bb, 
                      gcm = "EC-Earth3",
                      ssp = "ssp245", 
                      period = "2021_2040",
                      max_run = 0)

fut_proj_ts <- gcm_ts_input(dbCon, bbox = the_bb, 
                            gcm = "EC-Earth3",
                            ssp = "ssp245", 
                            years = 2021:2040,
                            max_run = 0)

hist_obs <- historic_input(dbCon, bbox = the_bb,
                           period = "2001_2020")
hist_obs_ts <- historic_input_ts(dbCon, bbox = the_bb,
                                 years = 2001:2020)
par(mfrow = c(1,4))
plot(crop(hist_proj[[1]][["EC-Earth3_Tmax_07_ensembleMean_2001"]], vancouver), 
     col = hcl.colors(50, "Reds", rev = 1), type = "continuous",
     main = "Max temp. July\nhistorical anomaly, 2001",
     mar = c(1, 2, 1, 4),
     fun = function() lines(vancouver))

plot(crop(hist_obs[[1]][["Tmax07"]], vancouver), 
     col = hcl.colors(50, "Reds", rev = 1), type = "continuous",
     mar = c(1, 2, 1, 4),
     ext = ext(vancouver), main = "Max temp. July\nobserved anomaly 2001-2020",
     fun = function() lines(vancouver))
plot(crop(hist_obs_ts[[1]][["Tmax07_2001"]], vancouver),
     col = hcl.colors(50, "Reds", rev = 1), type = "continuous",
     mar = c(2, 2, 1, 4),
     ext = ext(vancouver), main = "Max temp. July\nobserved anomaly 2001",
     fun = function() lines(vancouver))
plot(crop(fut_proj[[1]][["EC-Earth3_Tmax_07_ssp245_ensembleMean_2021_2040"]], vancouver),
     col = hcl.colors(50, "Reds", rev = 1), type = "continuous",
     mar = c(1, 2, 1, 4),
     ext = ext(vancouver), main = "Max temp. July\nfuture anomaly, 2021-2040",
     fun = function() lines(vancouver))
```

```{r, include = FALSE}
par(mfrow = c(1,1))
```


### 3) Downscale and calculate actual values (i.e., not anomalies)

Now that we have all necessary inputs, we can downscale the climate
data. To avoid repeating the same lines of code for each input, we'll
use `lapply` and `do.call` to iterate over the several climate inputs to
downscale.

Note that for `do.call` to work our list of climate inputs must be
named according to `downscale`'s argument names (you can list them with
`formalArgs(downscale)`).

```{r, results = 'hide'}
inputs <- list("gcm" = fut_proj,
               "historic" = hist_obs,
               "gcm_ts" = fut_proj_ts,
               "gcm_hist" = hist_proj,
               "historic_ts" = hist_obs_ts)

all_downscale <- sapply(names(inputs), 
                        function(input_arg, point_locations, normals, inputs) {
                          args <- list(inputs[[input_arg]])
                          names(args) <- input_arg
                          
                          ## add a few more arguments
                          args <- append(args, 
                                         list("xyz" = point_locations,
                                              "normal" = normals,
                                              "return_normal" = FALSE, 
                                              "vars" = "MAT", 
                                              "out_spatial" = FALSE))
                          
                          return(do.call(downscale, args))
                        }, normals = normals, inputs = inputs, point_locations)

all_downscale
```

```{r, echo = FALSE}
options(datatable.print.nrows = 10)

all_downscale
```

Binding the tables results in a similar table to the one we would have
achieved had we used `climr_downscale()`.

```{r, results = 'hide'}
all_downscale <- rbindlist(all_downscale, use.names = TRUE, fill = TRUE)
```

```{r, echo = FALSE}
knitr::kable(all_downscale[id == head(id, 1)], caption = "'all_downscale' table after binding. Outputs are show for one location ('id')")
```

## References
